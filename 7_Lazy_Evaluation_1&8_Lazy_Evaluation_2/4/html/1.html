<script src="../lib/fx.js"></script>

## L.flatten

<script>
    // flatten이 하고자 하는 것, like spread operator
    log([...[1, 2], 3, 4, ...[5, 6], ...[7, 8, 9]]);

    const isIterable = a => a && a[Symbol.iterator];

    L.flatten = function* (iter) {
        for (const a of iter) {
            if (isIterable(a)) for (const b of a) yield b;
            else yield a;
        }
    };

    var it = L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);
    // log([...it]);
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    log(take(3, L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]])));

    const flatten = pipe(L.flatten, takeAll);
    log(flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]));
</script>

## yield *

<script>
    L.flatten = function* (iter) {
        for (const a of iter) {
            if (isIterable(a)) for (const b of a) yield b
            else yield a;
        }
    };
</script>

`yield *`을 활용하면 위 코드를 아래와 같이 변경할 수 있습니다. `yield *iterable`은 `for (const val of iterable) yield val;` 과 같습니다.

<script>
    L.flatten = function* (iter) {
        for (const a of iter) {
            if (isIterable(a)) yield* a;
            else yield a;
        }
    };
</script>

## L.deepFlat

만일 깊은 Iterable을 모두 펼치고 싶다면 아래와 같이 `L.deepFlat`을 구현하여 사용할 수 있습니다. `L.deepFlat`은 깊은 Iterable을 펼쳐줍니다.

<script>
    L.deepFlat = function* f(iter) {
        for (const a of iter) {
            if (isIterable(a)) yield* f(a);
            else yield a;
        }
    };
    log([...L.deepFlat([1, [2, [3, 4], [[5]]]])]);
    // [1, 2, 3, 4, 5];
    console.clear();
</script>

## L.flatMap

<script>
    // log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a));
    // log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a.map(a => a * a)));
    // log(flatten([[1, 2], [3, 4], [5, 6, 7]].map(a => a.map(a => a * a))));
    // map을 통해 2차원 배열을 유지하고 다시 flatten으로 1차원 배열로 바뀌기 때문에 비효율적
    // 결국 모두 순회하기 떄문에 flatMap과 flatten(map)의 시간 복잡도는 같다

    // Lazy Evaluation
    L.flatMap = curry(pipe(L.map, L.flatten)); // 2번의 평가 지연
    const flatMap = curry(pipe(L.map, flatten)); // 1번의 평가 지연 후 flatten에서 전부 평가
    // var it = L.flatMap(map(a => a * a), [[1, 2], [3, 4], [5, 6, 7]]);
    var it = L.flatMap(map(a => a), [[1, 2], [3, 4], [5, 6, 7]]);
    log([...it]);
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    // log(it.next());
    log(flatMap(map(a => a), [[1, 2], [3, 4], [5, 6, 7]]));

    log(flatMap(L.range, [1, 2, 3]));
    // log(map(range, [1, 2, 3]));
    // log(flatMap(range, [1, 2, 3]));
    log(flatMap(range, map(a => a + 1, [1, 2, 3])));
    log(...L.flatMap(L.range, map(a => a + 1, [1, 2, 3])));

    var it = L.flatMap(L.range, map(a => a + 1, [1, 2, 3]));
    log(it.next());
    log(it.next());
    log(it.next());
    log(it.next());

    log(take(3, L.flatMap(L.range, map(a => a + 1, [1, 2, 3]))));
</script>


## 2차원 배열 다루기

<script>
</script>


## 지연성 / 이터러블 중심 프로그래밍 실무적인 코드

<script>
</script>